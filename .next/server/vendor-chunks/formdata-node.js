"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/formdata-node";
exports.ids = ["vendor-chunks/formdata-node"];
exports.modules = {

/***/ "(rsc)/./node_modules/formdata-node/lib/form-data.cjs":
/*!******************************************************!*\
  !*** ./node_modules/formdata-node/lib/form-data.cjs ***!
  \******************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  Blob: () => Blob,\n  File: () => File,\n  FormData: () => FormData\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/isFunction.ts\nvar isFunction = (value) => typeof value === \"function\";\n\n// src/isObject.ts\nvar isObject = (value) => typeof value === \"object\" && value != null && !Array.isArray(value);\n\n// src/isAsyncIterable.ts\nvar isAsyncIterable = (value) => isObject(value) && isFunction(value[Symbol.asyncIterator]);\n\n// src/blobHelpers.ts\nvar MAX_CHUNK_SIZE = 65536;\nasync function* clonePart(value) {\n  if (value.byteLength <= MAX_CHUNK_SIZE) {\n    yield value;\n    return;\n  }\n  let offset = 0;\n  while (offset < value.byteLength) {\n    const size = Math.min(value.byteLength - offset, MAX_CHUNK_SIZE);\n    const buffer = value.buffer.slice(offset, offset + size);\n    offset += buffer.byteLength;\n    yield new Uint8Array(buffer);\n  }\n}\nasync function* readStream(readable) {\n  const reader = readable.getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    yield value;\n  }\n}\nasync function* chunkStream(stream) {\n  for await (const value of stream) {\n    yield* clonePart(value);\n  }\n}\nvar getStreamIterator = (source) => {\n  if (isAsyncIterable(source)) {\n    return chunkStream(source);\n  }\n  if (isFunction(source.getReader)) {\n    return chunkStream(readStream(source));\n  }\n  throw new TypeError(\n    \"Unsupported data source: Expected either ReadableStream or async iterable.\"\n  );\n};\nasync function* consumeNodeBlob(blob) {\n  let position = 0;\n  while (position !== blob.size) {\n    const chunk = blob.slice(\n      position,\n      Math.min(blob.size, position + MAX_CHUNK_SIZE)\n    );\n    const buffer = await chunk.arrayBuffer();\n    position += buffer.byteLength;\n    yield new Uint8Array(buffer);\n  }\n}\nasync function* consumeBlobParts(parts, clone = false) {\n  for (const part of parts) {\n    if (ArrayBuffer.isView(part)) {\n      if (clone) {\n        yield* clonePart(part);\n      } else {\n        yield part;\n      }\n    } else if (isFunction(part.stream)) {\n      yield* getStreamIterator(part.stream());\n    } else {\n      yield* consumeNodeBlob(part);\n    }\n  }\n}\nfunction* sliceBlob(blobParts, blobSize, start = 0, end) {\n  end ??= blobSize;\n  let relativeStart = start < 0 ? Math.max(blobSize + start, 0) : Math.min(start, blobSize);\n  let relativeEnd = end < 0 ? Math.max(blobSize + end, 0) : Math.min(end, blobSize);\n  const span = Math.max(relativeEnd - relativeStart, 0);\n  let added = 0;\n  for (const part of blobParts) {\n    if (added >= span) {\n      break;\n    }\n    const partSize = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n    if (relativeStart && partSize <= relativeStart) {\n      relativeStart -= partSize;\n      relativeEnd -= partSize;\n    } else {\n      let chunk;\n      if (ArrayBuffer.isView(part)) {\n        chunk = part.subarray(relativeStart, Math.min(partSize, relativeEnd));\n        added += chunk.byteLength;\n      } else {\n        chunk = part.slice(relativeStart, Math.min(partSize, relativeEnd));\n        added += chunk.size;\n      }\n      relativeEnd -= partSize;\n      relativeStart = 0;\n      yield chunk;\n    }\n  }\n}\n\n// src/Blob.ts\nvar _parts, _type, _size;\nvar _Blob = class _Blob {\n  /**\n   * Returns a new [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) object.\n   * The content of the blob consists of the concatenation of the values given in the parameter array.\n   *\n   * @param blobParts An `Array` strings, or [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), [`ArrayBufferView`](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView), [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) objects, or a mix of any of such objects, that will be put inside the [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob).\n   * @param options An optional object of type `BlobPropertyBag`.\n   */\n  constructor(blobParts = [], options = {}) {\n    /**\n     * An `Array` of [`ArrayBufferView`](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView) or [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) objects, or a mix of any of such objects, that will be put inside the [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob).\n     */\n    __privateAdd(this, _parts, []);\n    /**\n     * Returns the [`MIME type`](https://developer.mozilla.org/en-US/docs/Glossary/MIME_type) of the [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File).\n     */\n    __privateAdd(this, _type, \"\");\n    /**\n     * Returns the size of the [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) in bytes.\n     */\n    __privateAdd(this, _size, 0);\n    options ??= {};\n    if (typeof blobParts !== \"object\" || blobParts === null) {\n      throw new TypeError(\n        \"Failed to construct 'Blob': The provided value cannot be converted to a sequence.\"\n      );\n    }\n    if (!isFunction(blobParts[Symbol.iterator])) {\n      throw new TypeError(\n        \"Failed to construct 'Blob': The object must have a callable @@iterator property.\"\n      );\n    }\n    if (typeof options !== \"object\" && !isFunction(options)) {\n      throw new TypeError(\n        \"Failed to construct 'Blob': parameter 2 cannot convert to dictionary.\"\n      );\n    }\n    const encoder = new TextEncoder();\n    for (const raw of blobParts) {\n      let part;\n      if (ArrayBuffer.isView(raw)) {\n        part = new Uint8Array(raw.buffer.slice(\n          raw.byteOffset,\n          raw.byteOffset + raw.byteLength\n        ));\n      } else if (raw instanceof ArrayBuffer) {\n        part = new Uint8Array(raw.slice(0));\n      } else if (raw instanceof _Blob) {\n        part = raw;\n      } else {\n        part = encoder.encode(String(raw));\n      }\n      __privateSet(this, _size, __privateGet(this, _size) + (ArrayBuffer.isView(part) ? part.byteLength : part.size));\n      __privateGet(this, _parts).push(part);\n    }\n    const type = options.type === void 0 ? \"\" : String(options.type);\n    __privateSet(this, _type, /^[\\x20-\\x7E]*$/.test(type) ? type : \"\");\n  }\n  static [Symbol.hasInstance](value) {\n    return Boolean(\n      value && typeof value === \"object\" && isFunction(value.constructor) && (isFunction(value.stream) || isFunction(value.arrayBuffer)) && /^(Blob|File)$/.test(value[Symbol.toStringTag])\n    );\n  }\n  /**\n   * Returns the [`MIME type`](https://developer.mozilla.org/en-US/docs/Glossary/MIME_type) of the [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File).\n   */\n  get type() {\n    return __privateGet(this, _type);\n  }\n  /**\n   * Returns the size of the [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) in bytes.\n   */\n  get size() {\n    return __privateGet(this, _size);\n  }\n  /**\n   * Creates and returns a new [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) object which contains data from a subset of the blob on which it's called.\n   *\n   * @param start An index into the Blob indicating the first byte to include in the new Blob. If you specify a negative value, it's treated as an offset from the end of the Blob toward the beginning. For example, -10 would be the 10th from last byte in the Blob. The default value is 0. If you specify a value for start that is larger than the size of the source Blob, the returned Blob has size 0 and contains no data.\n   * @param end An index into the Blob indicating the first byte that will *not* be included in the new Blob (i.e. the byte exactly at this index is not included). If you specify a negative value, it's treated as an offset from the end of the Blob toward the beginning. For example, -10 would be the 10th from last byte in the Blob. The default value is size.\n   * @param contentType The content type to assign to the new Blob; this will be the value of its type property. The default value is an empty string.\n   */\n  slice(start, end, contentType) {\n    return new _Blob(sliceBlob(__privateGet(this, _parts), this.size, start, end), {\n      type: contentType\n    });\n  }\n  /**\n   * Returns a [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) that resolves with a string containing the contents of the blob, interpreted as UTF-8.\n   */\n  async text() {\n    const decoder = new TextDecoder();\n    let result = \"\";\n    for await (const chunk of consumeBlobParts(__privateGet(this, _parts))) {\n      result += decoder.decode(chunk, { stream: true });\n    }\n    result += decoder.decode();\n    return result;\n  }\n  /**\n   * Returns a [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) that resolves with the contents of the blob as binary data contained in an [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer).\n   */\n  async arrayBuffer() {\n    const view = new Uint8Array(this.size);\n    let offset = 0;\n    for await (const chunk of consumeBlobParts(__privateGet(this, _parts))) {\n      view.set(chunk, offset);\n      offset += chunk.length;\n    }\n    return view.buffer;\n  }\n  /**\n   * Returns a [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream) which upon reading returns the data contained within the [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob).\n   */\n  stream() {\n    const iterator = consumeBlobParts(__privateGet(this, _parts), true);\n    return new ReadableStream({\n      async pull(controller) {\n        const { value, done } = await iterator.next();\n        if (done) {\n          return queueMicrotask(() => controller.close());\n        }\n        controller.enqueue(value);\n      },\n      async cancel() {\n        await iterator.return();\n      }\n    });\n  }\n  get [Symbol.toStringTag]() {\n    return \"Blob\";\n  }\n};\n_parts = new WeakMap();\n_type = new WeakMap();\n_size = new WeakMap();\nvar Blob = _Blob;\nObject.defineProperties(Blob.prototype, {\n  type: { enumerable: true },\n  size: { enumerable: true },\n  slice: { enumerable: true },\n  stream: { enumerable: true },\n  text: { enumerable: true },\n  arrayBuffer: { enumerable: true }\n});\n\n// src/isBlob.ts\nvar isBlob = (value) => value instanceof Blob;\n\n// src/File.ts\nvar _name, _lastModified;\nvar File = class extends Blob {\n  /**\n   * Creates a new File instance.\n   *\n   * @param fileBits An `Array` strings, or [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), [`ArrayBufferView`](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView), [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) objects, or a mix of any of such objects, that will be put inside the [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File).\n   * @param name The name of the file.\n   * @param options An options object containing optional attributes for the file.\n   */\n  constructor(fileBits, name, options = {}) {\n    super(fileBits, options);\n    /**\n     * Returns the name of the file referenced by the File object.\n     */\n    __privateAdd(this, _name, void 0);\n    /**\n     * The last modified date of the file as the number of milliseconds since the Unix epoch (January 1, 1970 at midnight). Files without a known last modified date return the current date.\n     */\n    __privateAdd(this, _lastModified, 0);\n    if (arguments.length < 2) {\n      throw new TypeError(\n        `Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`\n      );\n    }\n    __privateSet(this, _name, String(name));\n    const lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);\n    if (!Number.isNaN(lastModified)) {\n      __privateSet(this, _lastModified, lastModified);\n    }\n  }\n  static [Symbol.hasInstance](value) {\n    return value instanceof Blob && value[Symbol.toStringTag] === \"File\" && typeof value.name === \"string\";\n  }\n  /**\n   * Name of the file referenced by the File object.\n   */\n  get name() {\n    return __privateGet(this, _name);\n  }\n  /* c8 ignore next 3 */\n  get webkitRelativePath() {\n    return \"\";\n  }\n  /**\n   * The last modified date of the file as the number of milliseconds since the Unix epoch (January 1, 1970 at midnight). Files without a known last modified date return the current date.\n   */\n  get lastModified() {\n    return __privateGet(this, _lastModified);\n  }\n  get [Symbol.toStringTag]() {\n    return \"File\";\n  }\n};\n_name = new WeakMap();\n_lastModified = new WeakMap();\n\n// src/isFile.ts\nvar isFile = (value) => value instanceof File;\n\n// src/FormData.ts\nvar _entries, _setEntry, setEntry_fn;\nvar FormData = class {\n  constructor() {\n    __privateAdd(this, _setEntry);\n    /**\n     * Stores internal data for every entry\n     */\n    __privateAdd(this, _entries, /* @__PURE__ */ new Map());\n  }\n  static [Symbol.hasInstance](value) {\n    if (!value) {\n      return false;\n    }\n    const val = value;\n    return Boolean(\n      isFunction(val.constructor) && val[Symbol.toStringTag] === \"FormData\" && isFunction(val.append) && isFunction(val.set) && isFunction(val.get) && isFunction(val.getAll) && isFunction(val.has) && isFunction(val.delete) && isFunction(val.entries) && isFunction(val.values) && isFunction(val.keys) && isFunction(val[Symbol.iterator]) && isFunction(val.forEach)\n    );\n  }\n  /**\n   * Appends a new value onto an existing key inside a FormData object,\n   * or adds the key if it does not already exist.\n   *\n   * The difference between `set()` and `append()` is that if the specified key already exists, `set()` will overwrite all existing values with the new one, whereas `append()` will append the new value onto the end of the existing set of values.\n   *\n   * @param name The name of the field whose data is contained in `value`.\n   * @param value The field's value. This can be [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob)\n    or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File). If none of these are specified the value is converted to a string.\n   * @param fileName The filename reported to the server, when a Blob or File is passed as the second parameter. The default filename for Blob objects is \"blob\". The default filename for File objects is the file's filename.\n   */\n  append(name, value, fileName) {\n    __privateMethod(this, _setEntry, setEntry_fn).call(this, {\n      name,\n      fileName,\n      append: true,\n      rawValue: value,\n      argsLength: arguments.length\n    });\n  }\n  /**\n   * Set a new value for an existing key inside FormData,\n   * or add the new field if it does not already exist.\n   *\n   * @param name The name of the field whose data is contained in `value`.\n   * @param value The field's value. This can be [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob)\n    or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File). If none of these are specified the value is converted to a string.\n   * @param fileName The filename reported to the server, when a Blob or File is passed as the second parameter. The default filename for Blob objects is \"blob\". The default filename for File objects is the file's filename.\n   *\n   */\n  set(name, value, fileName) {\n    __privateMethod(this, _setEntry, setEntry_fn).call(this, {\n      name,\n      fileName,\n      append: false,\n      rawValue: value,\n      argsLength: arguments.length\n    });\n  }\n  /**\n   * Returns the first value associated with a given key from within a `FormData` object.\n   * If you expect multiple values and want all of them, use the `getAll()` method instead.\n   *\n   * @param {string} name A name of the value you want to retrieve.\n   *\n   * @returns A `FormDataEntryValue` containing the value. If the key doesn't exist, the method returns null.\n   */\n  get(name) {\n    const field = __privateGet(this, _entries).get(String(name));\n    if (!field) {\n      return null;\n    }\n    return field[0];\n  }\n  /**\n   * Returns all the values associated with a given key from within a `FormData` object.\n   *\n   * @param {string} name A name of the value you want to retrieve.\n   *\n   * @returns An array of `FormDataEntryValue` whose key matches the value passed in the `name` parameter. If the key doesn't exist, the method returns an empty list.\n   */\n  getAll(name) {\n    const field = __privateGet(this, _entries).get(String(name));\n    if (!field) {\n      return [];\n    }\n    return field.slice();\n  }\n  /**\n   * Returns a boolean stating whether a `FormData` object contains a certain key.\n   *\n   * @param name A string representing the name of the key you want to test for.\n   *\n   * @return A boolean value.\n   */\n  has(name) {\n    return __privateGet(this, _entries).has(String(name));\n  }\n  /**\n   * Deletes a key and its value(s) from a `FormData` object.\n   *\n   * @param name The name of the key you want to delete.\n   */\n  delete(name) {\n    __privateGet(this, _entries).delete(String(name));\n  }\n  /**\n   * Returns an [`iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) allowing to go through all keys contained in this `FormData` object.\n   * Each key is a `string`.\n   */\n  *keys() {\n    for (const key of __privateGet(this, _entries).keys()) {\n      yield key;\n    }\n  }\n  /**\n   * Returns an [`iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) allowing to go through the `FormData` key/value pairs.\n   * The key of each pair is a string; the value is a [`FormDataValue`](https://developer.mozilla.org/en-US/docs/Web/API/FormDataEntryValue).\n   */\n  *entries() {\n    for (const name of this.keys()) {\n      const values = this.getAll(name);\n      for (const value of values) {\n        yield [name, value];\n      }\n    }\n  }\n  /**\n   * Returns an [`iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) allowing to go through all values contained in this object `FormData` object.\n   * Each value is a [`FormDataValue`](https://developer.mozilla.org/en-US/docs/Web/API/FormDataEntryValue).\n   */\n  *values() {\n    for (const [, value] of this) {\n      yield value;\n    }\n  }\n  /**\n   * An alias for FormData#entries()\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Executes given callback function for each field of the FormData instance\n   */\n  forEach(callback, thisArg) {\n    for (const [name, value] of this) {\n      callback.call(thisArg, value, name, this);\n    }\n  }\n  get [Symbol.toStringTag]() {\n    return \"FormData\";\n  }\n};\n_entries = new WeakMap();\n_setEntry = new WeakSet();\nsetEntry_fn = function({\n  name,\n  rawValue,\n  append,\n  fileName,\n  argsLength\n}) {\n  const methodName = append ? \"append\" : \"set\";\n  if (argsLength < 2) {\n    throw new TypeError(\n      `Failed to execute '${methodName}' on 'FormData': 2 arguments required, but only ${argsLength} present.`\n    );\n  }\n  name = String(name);\n  let value;\n  if (isFile(rawValue)) {\n    value = fileName === void 0 ? rawValue : new File([rawValue], fileName, {\n      // otherwise, create new File with given fileName\n      type: rawValue.type,\n      lastModified: rawValue.lastModified\n    });\n  } else if (isBlob(rawValue)) {\n    value = new File([rawValue], fileName === void 0 ? \"blob\" : fileName, {\n      type: rawValue.type\n    });\n  } else if (fileName) {\n    throw new TypeError(\n      `Failed to execute '${methodName}' on 'FormData': parameter 2 is not of type 'Blob'.`\n    );\n  } else {\n    value = String(rawValue);\n  }\n  const values = __privateGet(this, _entries).get(name);\n  if (!values) {\n    return void __privateGet(this, _entries).set(name, [value]);\n  }\n  if (!append) {\n    return void __privateGet(this, _entries).set(name, [value]);\n  }\n  values.push(value);\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n/*! Based on fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> & David Frank */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZm9ybWRhdGEtbm9kZS9saWIvZm9ybS1kYXRhLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQkFBa0I7QUFDNUIsVUFBVSxrQkFBa0I7QUFDNUIsV0FBVyxrQkFBa0I7QUFDN0IsWUFBWSxrQkFBa0I7QUFDOUIsVUFBVSxrQkFBa0I7QUFDNUIsaUJBQWlCO0FBQ2pCLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGtCQUFrQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVyxrREFBa0QsWUFBWTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUlMO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2RjYXN0ci8uL25vZGVfbW9kdWxlcy9mb3JtZGF0YS1ub2RlL2xpYi9mb3JtLWRhdGEuY2pzPzNjZTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIF9fYWNjZXNzQ2hlY2sgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4ge1xuICBpZiAoIW1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xufTtcbnZhciBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpO1xuICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKTtcbn07XG52YXIgX19wcml2YXRlQWRkID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4ge1xuICBpZiAobWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufTtcbnZhciBfX3ByaXZhdGVTZXQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpO1xuICBzZXR0ZXIgPyBzZXR0ZXIuY2FsbChvYmosIHZhbHVlKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX19wcml2YXRlTWV0aG9kID0gKG9iaiwgbWVtYmVyLCBtZXRob2QpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJhY2Nlc3MgcHJpdmF0ZSBtZXRob2RcIik7XG4gIHJldHVybiBtZXRob2Q7XG59O1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBzcmNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3JjX2V4cG9ydHMsIHtcbiAgQmxvYjogKCkgPT4gQmxvYixcbiAgRmlsZTogKCkgPT4gRmlsZSxcbiAgRm9ybURhdGE6ICgpID0+IEZvcm1EYXRhXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHNyY19leHBvcnRzKTtcblxuLy8gc3JjL2lzRnVuY3Rpb24udHNcbnZhciBpc0Z1bmN0aW9uID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcblxuLy8gc3JjL2lzT2JqZWN0LnRzXG52YXIgaXNPYmplY3QgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcblxuLy8gc3JjL2lzQXN5bmNJdGVyYWJsZS50c1xudmFyIGlzQXN5bmNJdGVyYWJsZSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpICYmIGlzRnVuY3Rpb24odmFsdWVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKTtcblxuLy8gc3JjL2Jsb2JIZWxwZXJzLnRzXG52YXIgTUFYX0NIVU5LX1NJWkUgPSA2NTUzNjtcbmFzeW5jIGZ1bmN0aW9uKiBjbG9uZVBhcnQodmFsdWUpIHtcbiAgaWYgKHZhbHVlLmJ5dGVMZW5ndGggPD0gTUFYX0NIVU5LX1NJWkUpIHtcbiAgICB5aWVsZCB2YWx1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG9mZnNldCA9IDA7XG4gIHdoaWxlIChvZmZzZXQgPCB2YWx1ZS5ieXRlTGVuZ3RoKSB7XG4gICAgY29uc3Qgc2l6ZSA9IE1hdGgubWluKHZhbHVlLmJ5dGVMZW5ndGggLSBvZmZzZXQsIE1BWF9DSFVOS19TSVpFKTtcbiAgICBjb25zdCBidWZmZXIgPSB2YWx1ZS5idWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzaXplKTtcbiAgICBvZmZzZXQgKz0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgeWllbGQgbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24qIHJlYWRTdHJlYW0ocmVhZGFibGUpIHtcbiAgY29uc3QgcmVhZGVyID0gcmVhZGFibGUuZ2V0UmVhZGVyKCk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHlpZWxkIHZhbHVlO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiogY2h1bmtTdHJlYW0oc3RyZWFtKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2Ygc3RyZWFtKSB7XG4gICAgeWllbGQqIGNsb25lUGFydCh2YWx1ZSk7XG4gIH1cbn1cbnZhciBnZXRTdHJlYW1JdGVyYXRvciA9IChzb3VyY2UpID0+IHtcbiAgaWYgKGlzQXN5bmNJdGVyYWJsZShzb3VyY2UpKSB7XG4gICAgcmV0dXJuIGNodW5rU3RyZWFtKHNvdXJjZSk7XG4gIH1cbiAgaWYgKGlzRnVuY3Rpb24oc291cmNlLmdldFJlYWRlcikpIHtcbiAgICByZXR1cm4gY2h1bmtTdHJlYW0ocmVhZFN0cmVhbShzb3VyY2UpKTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgIFwiVW5zdXBwb3J0ZWQgZGF0YSBzb3VyY2U6IEV4cGVjdGVkIGVpdGhlciBSZWFkYWJsZVN0cmVhbSBvciBhc3luYyBpdGVyYWJsZS5cIlxuICApO1xufTtcbmFzeW5jIGZ1bmN0aW9uKiBjb25zdW1lTm9kZUJsb2IoYmxvYikge1xuICBsZXQgcG9zaXRpb24gPSAwO1xuICB3aGlsZSAocG9zaXRpb24gIT09IGJsb2Iuc2l6ZSkge1xuICAgIGNvbnN0IGNodW5rID0gYmxvYi5zbGljZShcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgTWF0aC5taW4oYmxvYi5zaXplLCBwb3NpdGlvbiArIE1BWF9DSFVOS19TSVpFKVxuICAgICk7XG4gICAgY29uc3QgYnVmZmVyID0gYXdhaXQgY2h1bmsuYXJyYXlCdWZmZXIoKTtcbiAgICBwb3NpdGlvbiArPSBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgICB5aWVsZCBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiogY29uc3VtZUJsb2JQYXJ0cyhwYXJ0cywgY2xvbmUgPSBmYWxzZSkge1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHBhcnQpKSB7XG4gICAgICBpZiAoY2xvbmUpIHtcbiAgICAgICAgeWllbGQqIGNsb25lUGFydChwYXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIHBhcnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHBhcnQuc3RyZWFtKSkge1xuICAgICAgeWllbGQqIGdldFN0cmVhbUl0ZXJhdG9yKHBhcnQuc3RyZWFtKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB5aWVsZCogY29uc3VtZU5vZGVCbG9iKHBhcnQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24qIHNsaWNlQmxvYihibG9iUGFydHMsIGJsb2JTaXplLCBzdGFydCA9IDAsIGVuZCkge1xuICBlbmQgPz89IGJsb2JTaXplO1xuICBsZXQgcmVsYXRpdmVTdGFydCA9IHN0YXJ0IDwgMCA/IE1hdGgubWF4KGJsb2JTaXplICsgc3RhcnQsIDApIDogTWF0aC5taW4oc3RhcnQsIGJsb2JTaXplKTtcbiAgbGV0IHJlbGF0aXZlRW5kID0gZW5kIDwgMCA/IE1hdGgubWF4KGJsb2JTaXplICsgZW5kLCAwKSA6IE1hdGgubWluKGVuZCwgYmxvYlNpemUpO1xuICBjb25zdCBzcGFuID0gTWF0aC5tYXgocmVsYXRpdmVFbmQgLSByZWxhdGl2ZVN0YXJ0LCAwKTtcbiAgbGV0IGFkZGVkID0gMDtcbiAgZm9yIChjb25zdCBwYXJ0IG9mIGJsb2JQYXJ0cykge1xuICAgIGlmIChhZGRlZCA+PSBzcGFuKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgcGFydFNpemUgPSBBcnJheUJ1ZmZlci5pc1ZpZXcocGFydCkgPyBwYXJ0LmJ5dGVMZW5ndGggOiBwYXJ0LnNpemU7XG4gICAgaWYgKHJlbGF0aXZlU3RhcnQgJiYgcGFydFNpemUgPD0gcmVsYXRpdmVTdGFydCkge1xuICAgICAgcmVsYXRpdmVTdGFydCAtPSBwYXJ0U2l6ZTtcbiAgICAgIHJlbGF0aXZlRW5kIC09IHBhcnRTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY2h1bms7XG4gICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHBhcnQpKSB7XG4gICAgICAgIGNodW5rID0gcGFydC5zdWJhcnJheShyZWxhdGl2ZVN0YXJ0LCBNYXRoLm1pbihwYXJ0U2l6ZSwgcmVsYXRpdmVFbmQpKTtcbiAgICAgICAgYWRkZWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNodW5rID0gcGFydC5zbGljZShyZWxhdGl2ZVN0YXJ0LCBNYXRoLm1pbihwYXJ0U2l6ZSwgcmVsYXRpdmVFbmQpKTtcbiAgICAgICAgYWRkZWQgKz0gY2h1bmsuc2l6ZTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlRW5kIC09IHBhcnRTaXplO1xuICAgICAgcmVsYXRpdmVTdGFydCA9IDA7XG4gICAgICB5aWVsZCBjaHVuaztcbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL0Jsb2IudHNcbnZhciBfcGFydHMsIF90eXBlLCBfc2l6ZTtcbnZhciBfQmxvYiA9IGNsYXNzIF9CbG9iIHtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgW2BCbG9iYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IpIG9iamVjdC5cbiAgICogVGhlIGNvbnRlbnQgb2YgdGhlIGJsb2IgY29uc2lzdHMgb2YgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIHZhbHVlcyBnaXZlbiBpbiB0aGUgcGFyYW1ldGVyIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0gYmxvYlBhcnRzIEFuIGBBcnJheWAgc3RyaW5ncywgb3IgW2BBcnJheUJ1ZmZlcmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5QnVmZmVyKSwgW2BBcnJheUJ1ZmZlclZpZXdgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXJyYXlCdWZmZXJWaWV3KSwgW2BCbG9iYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IpIG9iamVjdHMsIG9yIGEgbWl4IG9mIGFueSBvZiBzdWNoIG9iamVjdHMsIHRoYXQgd2lsbCBiZSBwdXQgaW5zaWRlIHRoZSBbYEJsb2JgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYikuXG4gICAqIEBwYXJhbSBvcHRpb25zIEFuIG9wdGlvbmFsIG9iamVjdCBvZiB0eXBlIGBCbG9iUHJvcGVydHlCYWdgLlxuICAgKi9cbiAgY29uc3RydWN0b3IoYmxvYlBhcnRzID0gW10sIG9wdGlvbnMgPSB7fSkge1xuICAgIC8qKlxuICAgICAqIEFuIGBBcnJheWAgb2YgW2BBcnJheUJ1ZmZlclZpZXdgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXJyYXlCdWZmZXJWaWV3KSBvciBbYEJsb2JgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYikgb2JqZWN0cywgb3IgYSBtaXggb2YgYW55IG9mIHN1Y2ggb2JqZWN0cywgdGhhdCB3aWxsIGJlIHB1dCBpbnNpZGUgdGhlIFtgQmxvYmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9iKS5cbiAgICAgKi9cbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3BhcnRzLCBbXSk7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgW2BNSU1FIHR5cGVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0dsb3NzYXJ5L01JTUVfdHlwZSkgb2YgdGhlIFtgQmxvYmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9iKSBvciBbYEZpbGVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZSkuXG4gICAgICovXG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF90eXBlLCBcIlwiKTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBbYEJsb2JgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYikgb3IgW2BGaWxlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZpbGUpIGluIGJ5dGVzLlxuICAgICAqL1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc2l6ZSwgMCk7XG4gICAgb3B0aW9ucyA/Pz0ge307XG4gICAgaWYgKHR5cGVvZiBibG9iUGFydHMgIT09IFwib2JqZWN0XCIgfHwgYmxvYlBhcnRzID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ0Jsb2InOiBUaGUgcHJvdmlkZWQgdmFsdWUgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIHNlcXVlbmNlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWlzRnVuY3Rpb24oYmxvYlBhcnRzW1N5bWJvbC5pdGVyYXRvcl0pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ0Jsb2InOiBUaGUgb2JqZWN0IG11c3QgaGF2ZSBhIGNhbGxhYmxlIEBAaXRlcmF0b3IgcHJvcGVydHkuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gXCJvYmplY3RcIiAmJiAhaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJGYWlsZWQgdG8gY29uc3RydWN0ICdCbG9iJzogcGFyYW1ldGVyIDIgY2Fubm90IGNvbnZlcnQgdG8gZGljdGlvbmFyeS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGZvciAoY29uc3QgcmF3IG9mIGJsb2JQYXJ0cykge1xuICAgICAgbGV0IHBhcnQ7XG4gICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHJhdykpIHtcbiAgICAgICAgcGFydCA9IG5ldyBVaW50OEFycmF5KHJhdy5idWZmZXIuc2xpY2UoXG4gICAgICAgICAgcmF3LmJ5dGVPZmZzZXQsXG4gICAgICAgICAgcmF3LmJ5dGVPZmZzZXQgKyByYXcuYnl0ZUxlbmd0aFxuICAgICAgICApKTtcbiAgICAgIH0gZWxzZSBpZiAocmF3IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcGFydCA9IG5ldyBVaW50OEFycmF5KHJhdy5zbGljZSgwKSk7XG4gICAgICB9IGVsc2UgaWYgKHJhdyBpbnN0YW5jZW9mIF9CbG9iKSB7XG4gICAgICAgIHBhcnQgPSByYXc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0ID0gZW5jb2Rlci5lbmNvZGUoU3RyaW5nKHJhdykpO1xuICAgICAgfVxuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9zaXplLCBfX3ByaXZhdGVHZXQodGhpcywgX3NpemUpICsgKEFycmF5QnVmZmVyLmlzVmlldyhwYXJ0KSA/IHBhcnQuYnl0ZUxlbmd0aCA6IHBhcnQuc2l6ZSkpO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9wYXJ0cykucHVzaChwYXJ0KTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IG9wdGlvbnMudHlwZSA9PT0gdm9pZCAwID8gXCJcIiA6IFN0cmluZyhvcHRpb25zLnR5cGUpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfdHlwZSwgL15bXFx4MjAtXFx4N0VdKiQvLnRlc3QodHlwZSkgPyB0eXBlIDogXCJcIik7XG4gIH1cbiAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdKHZhbHVlKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oXG4gICAgICB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgaXNGdW5jdGlvbih2YWx1ZS5jb25zdHJ1Y3RvcikgJiYgKGlzRnVuY3Rpb24odmFsdWUuc3RyZWFtKSB8fCBpc0Z1bmN0aW9uKHZhbHVlLmFycmF5QnVmZmVyKSkgJiYgL14oQmxvYnxGaWxlKSQvLnRlc3QodmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBbYE1JTUUgdHlwZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvR2xvc3NhcnkvTUlNRV90eXBlKSBvZiB0aGUgW2BCbG9iYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IpIG9yIFtgRmlsZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlKS5cbiAgICovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX3R5cGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBbYEJsb2JgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYikgb3IgW2BGaWxlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZpbGUpIGluIGJ5dGVzLlxuICAgKi9cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2l6ZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgW2BCbG9iYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IpIG9iamVjdCB3aGljaCBjb250YWlucyBkYXRhIGZyb20gYSBzdWJzZXQgb2YgdGhlIGJsb2Igb24gd2hpY2ggaXQncyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzdGFydCBBbiBpbmRleCBpbnRvIHRoZSBCbG9iIGluZGljYXRpbmcgdGhlIGZpcnN0IGJ5dGUgdG8gaW5jbHVkZSBpbiB0aGUgbmV3IEJsb2IuIElmIHlvdSBzcGVjaWZ5IGEgbmVnYXRpdmUgdmFsdWUsIGl0J3MgdHJlYXRlZCBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBCbG9iIHRvd2FyZCB0aGUgYmVnaW5uaW5nLiBGb3IgZXhhbXBsZSwgLTEwIHdvdWxkIGJlIHRoZSAxMHRoIGZyb20gbGFzdCBieXRlIGluIHRoZSBCbG9iLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAwLiBJZiB5b3Ugc3BlY2lmeSBhIHZhbHVlIGZvciBzdGFydCB0aGF0IGlzIGxhcmdlciB0aGFuIHRoZSBzaXplIG9mIHRoZSBzb3VyY2UgQmxvYiwgdGhlIHJldHVybmVkIEJsb2IgaGFzIHNpemUgMCBhbmQgY29udGFpbnMgbm8gZGF0YS5cbiAgICogQHBhcmFtIGVuZCBBbiBpbmRleCBpbnRvIHRoZSBCbG9iIGluZGljYXRpbmcgdGhlIGZpcnN0IGJ5dGUgdGhhdCB3aWxsICpub3QqIGJlIGluY2x1ZGVkIGluIHRoZSBuZXcgQmxvYiAoaS5lLiB0aGUgYnl0ZSBleGFjdGx5IGF0IHRoaXMgaW5kZXggaXMgbm90IGluY2x1ZGVkKS4gSWYgeW91IHNwZWNpZnkgYSBuZWdhdGl2ZSB2YWx1ZSwgaXQncyB0cmVhdGVkIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIEJsb2IgdG93YXJkIHRoZSBiZWdpbm5pbmcuIEZvciBleGFtcGxlLCAtMTAgd291bGQgYmUgdGhlIDEwdGggZnJvbSBsYXN0IGJ5dGUgaW4gdGhlIEJsb2IuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHNpemUuXG4gICAqIEBwYXJhbSBjb250ZW50VHlwZSBUaGUgY29udGVudCB0eXBlIHRvIGFzc2lnbiB0byB0aGUgbmV3IEJsb2I7IHRoaXMgd2lsbCBiZSB0aGUgdmFsdWUgb2YgaXRzIHR5cGUgcHJvcGVydHkuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGFuIGVtcHR5IHN0cmluZy5cbiAgICovXG4gIHNsaWNlKHN0YXJ0LCBlbmQsIGNvbnRlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBfQmxvYihzbGljZUJsb2IoX19wcml2YXRlR2V0KHRoaXMsIF9wYXJ0cyksIHRoaXMuc2l6ZSwgc3RhcnQsIGVuZCksIHtcbiAgICAgIHR5cGU6IGNvbnRlbnRUeXBlXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBbYFByb21pc2VgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm9taXNlKSB0aGF0IHJlc29sdmVzIHdpdGggYSBzdHJpbmcgY29udGFpbmluZyB0aGUgY29udGVudHMgb2YgdGhlIGJsb2IsIGludGVycHJldGVkIGFzIFVURi04LlxuICAgKi9cbiAgYXN5bmMgdGV4dCgpIHtcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBjb25zdW1lQmxvYlBhcnRzKF9fcHJpdmF0ZUdldCh0aGlzLCBfcGFydHMpKSkge1xuICAgICAgcmVzdWx0ICs9IGRlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgcmVzdWx0ICs9IGRlY29kZXIuZGVjb2RlKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIFtgUHJvbWlzZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb21pc2UpIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgY29udGVudHMgb2YgdGhlIGJsb2IgYXMgYmluYXJ5IGRhdGEgY29udGFpbmVkIGluIGFuIFtgQXJyYXlCdWZmZXJgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheUJ1ZmZlcikuXG4gICAqL1xuICBhc3luYyBhcnJheUJ1ZmZlcigpIHtcbiAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5zaXplKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGNvbnN1bWVCbG9iUGFydHMoX19wcml2YXRlR2V0KHRoaXMsIF9wYXJ0cykpKSB7XG4gICAgICB2aWV3LnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiB2aWV3LmJ1ZmZlcjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIFtgUmVhZGFibGVTdHJlYW1gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUmVhZGFibGVTdHJlYW0pIHdoaWNoIHVwb24gcmVhZGluZyByZXR1cm5zIHRoZSBkYXRhIGNvbnRhaW5lZCB3aXRoaW4gdGhlIFtgQmxvYmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9iKS5cbiAgICovXG4gIHN0cmVhbSgpIHtcbiAgICBjb25zdCBpdGVyYXRvciA9IGNvbnN1bWVCbG9iUGFydHMoX19wcml2YXRlR2V0KHRoaXMsIF9wYXJ0cyksIHRydWUpO1xuICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gcXVldWVNaWNyb3Rhc2soKCkgPT4gY29udHJvbGxlci5jbG9zZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIGNhbmNlbCgpIHtcbiAgICAgICAgYXdhaXQgaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIkJsb2JcIjtcbiAgfVxufTtcbl9wYXJ0cyA9IG5ldyBXZWFrTWFwKCk7XG5fdHlwZSA9IG5ldyBXZWFrTWFwKCk7XG5fc2l6ZSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgQmxvYiA9IF9CbG9iO1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQmxvYi5wcm90b3R5cGUsIHtcbiAgdHlwZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBzbGljZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHN0cmVhbTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHRleHQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBhcnJheUJ1ZmZlcjogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuXG4vLyBzcmMvaXNCbG9iLnRzXG52YXIgaXNCbG9iID0gKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIEJsb2I7XG5cbi8vIHNyYy9GaWxlLnRzXG52YXIgX25hbWUsIF9sYXN0TW9kaWZpZWQ7XG52YXIgRmlsZSA9IGNsYXNzIGV4dGVuZHMgQmxvYiB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEZpbGUgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSBmaWxlQml0cyBBbiBgQXJyYXlgIHN0cmluZ3MsIG9yIFtgQXJyYXlCdWZmZXJgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheUJ1ZmZlciksIFtgQXJyYXlCdWZmZXJWaWV3YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FycmF5QnVmZmVyVmlldyksIFtgQmxvYmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9iKSBvYmplY3RzLCBvciBhIG1peCBvZiBhbnkgb2Ygc3VjaCBvYmplY3RzLCB0aGF0IHdpbGwgYmUgcHV0IGluc2lkZSB0aGUgW2BGaWxlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZpbGUpLlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZmlsZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgQW4gb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyBvcHRpb25hbCBhdHRyaWJ1dGVzIGZvciB0aGUgZmlsZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGZpbGVCaXRzLCBuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihmaWxlQml0cywgb3B0aW9ucyk7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgZmlsZSByZWZlcmVuY2VkIGJ5IHRoZSBGaWxlIG9iamVjdC5cbiAgICAgKi9cbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX25hbWUsIHZvaWQgMCk7XG4gICAgLyoqXG4gICAgICogVGhlIGxhc3QgbW9kaWZpZWQgZGF0ZSBvZiB0aGUgZmlsZSBhcyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgVW5peCBlcG9jaCAoSmFudWFyeSAxLCAxOTcwIGF0IG1pZG5pZ2h0KS4gRmlsZXMgd2l0aG91dCBhIGtub3duIGxhc3QgbW9kaWZpZWQgZGF0ZSByZXR1cm4gdGhlIGN1cnJlbnQgZGF0ZS5cbiAgICAgKi9cbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2xhc3RNb2RpZmllZCwgMCk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIGNvbnN0cnVjdCAnRmlsZSc6IDIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke2FyZ3VtZW50cy5sZW5ndGh9IHByZXNlbnQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9uYW1lLCBTdHJpbmcobmFtZSkpO1xuICAgIGNvbnN0IGxhc3RNb2RpZmllZCA9IG9wdGlvbnMubGFzdE1vZGlmaWVkID09PSB2b2lkIDAgPyBEYXRlLm5vdygpIDogTnVtYmVyKG9wdGlvbnMubGFzdE1vZGlmaWVkKTtcbiAgICBpZiAoIU51bWJlci5pc05hTihsYXN0TW9kaWZpZWQpKSB7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2xhc3RNb2RpZmllZCwgbGFzdE1vZGlmaWVkKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQmxvYiAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSBcIkZpbGVcIiAmJiB0eXBlb2YgdmFsdWUubmFtZSA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuICAvKipcbiAgICogTmFtZSBvZiB0aGUgZmlsZSByZWZlcmVuY2VkIGJ5IHRoZSBGaWxlIG9iamVjdC5cbiAgICovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX25hbWUpO1xuICB9XG4gIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgZ2V0IHdlYmtpdFJlbGF0aXZlUGF0aCgpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICAvKipcbiAgICogVGhlIGxhc3QgbW9kaWZpZWQgZGF0ZSBvZiB0aGUgZmlsZSBhcyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgVW5peCBlcG9jaCAoSmFudWFyeSAxLCAxOTcwIGF0IG1pZG5pZ2h0KS4gRmlsZXMgd2l0aG91dCBhIGtub3duIGxhc3QgbW9kaWZpZWQgZGF0ZSByZXR1cm4gdGhlIGN1cnJlbnQgZGF0ZS5cbiAgICovXG4gIGdldCBsYXN0TW9kaWZpZWQoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGFzdE1vZGlmaWVkKTtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiRmlsZVwiO1xuICB9XG59O1xuX25hbWUgPSBuZXcgV2Vha01hcCgpO1xuX2xhc3RNb2RpZmllZCA9IG5ldyBXZWFrTWFwKCk7XG5cbi8vIHNyYy9pc0ZpbGUudHNcbnZhciBpc0ZpbGUgPSAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2YgRmlsZTtcblxuLy8gc3JjL0Zvcm1EYXRhLnRzXG52YXIgX2VudHJpZXMsIF9zZXRFbnRyeSwgc2V0RW50cnlfZm47XG52YXIgRm9ybURhdGEgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc2V0RW50cnkpO1xuICAgIC8qKlxuICAgICAqIFN0b3JlcyBpbnRlcm5hbCBkYXRhIGZvciBldmVyeSBlbnRyeVxuICAgICAqL1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZW50cmllcywgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIH1cbiAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB2YWwgPSB2YWx1ZTtcbiAgICByZXR1cm4gQm9vbGVhbihcbiAgICAgIGlzRnVuY3Rpb24odmFsLmNvbnN0cnVjdG9yKSAmJiB2YWxbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gXCJGb3JtRGF0YVwiICYmIGlzRnVuY3Rpb24odmFsLmFwcGVuZCkgJiYgaXNGdW5jdGlvbih2YWwuc2V0KSAmJiBpc0Z1bmN0aW9uKHZhbC5nZXQpICYmIGlzRnVuY3Rpb24odmFsLmdldEFsbCkgJiYgaXNGdW5jdGlvbih2YWwuaGFzKSAmJiBpc0Z1bmN0aW9uKHZhbC5kZWxldGUpICYmIGlzRnVuY3Rpb24odmFsLmVudHJpZXMpICYmIGlzRnVuY3Rpb24odmFsLnZhbHVlcykgJiYgaXNGdW5jdGlvbih2YWwua2V5cykgJiYgaXNGdW5jdGlvbih2YWxbU3ltYm9sLml0ZXJhdG9yXSkgJiYgaXNGdW5jdGlvbih2YWwuZm9yRWFjaClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBBcHBlbmRzIGEgbmV3IHZhbHVlIG9udG8gYW4gZXhpc3Rpbmcga2V5IGluc2lkZSBhIEZvcm1EYXRhIG9iamVjdCxcbiAgICogb3IgYWRkcyB0aGUga2V5IGlmIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAqXG4gICAqIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gYHNldCgpYCBhbmQgYGFwcGVuZCgpYCBpcyB0aGF0IGlmIHRoZSBzcGVjaWZpZWQga2V5IGFscmVhZHkgZXhpc3RzLCBgc2V0KClgIHdpbGwgb3ZlcndyaXRlIGFsbCBleGlzdGluZyB2YWx1ZXMgd2l0aCB0aGUgbmV3IG9uZSwgd2hlcmVhcyBgYXBwZW5kKClgIHdpbGwgYXBwZW5kIHRoZSBuZXcgdmFsdWUgb250byB0aGUgZW5kIG9mIHRoZSBleGlzdGluZyBzZXQgb2YgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZmllbGQgd2hvc2UgZGF0YSBpcyBjb250YWluZWQgaW4gYHZhbHVlYC5cbiAgICogQHBhcmFtIHZhbHVlIFRoZSBmaWVsZCdzIHZhbHVlLiBUaGlzIGNhbiBiZSBbYEJsb2JgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYilcbiAgICBvciBbYEZpbGVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZSkuIElmIG5vbmUgb2YgdGhlc2UgYXJlIHNwZWNpZmllZCB0aGUgdmFsdWUgaXMgY29udmVydGVkIHRvIGEgc3RyaW5nLlxuICAgKiBAcGFyYW0gZmlsZU5hbWUgVGhlIGZpbGVuYW1lIHJlcG9ydGVkIHRvIHRoZSBzZXJ2ZXIsIHdoZW4gYSBCbG9iIG9yIEZpbGUgaXMgcGFzc2VkIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLiBUaGUgZGVmYXVsdCBmaWxlbmFtZSBmb3IgQmxvYiBvYmplY3RzIGlzIFwiYmxvYlwiLiBUaGUgZGVmYXVsdCBmaWxlbmFtZSBmb3IgRmlsZSBvYmplY3RzIGlzIHRoZSBmaWxlJ3MgZmlsZW5hbWUuXG4gICAqL1xuICBhcHBlbmQobmFtZSwgdmFsdWUsIGZpbGVOYW1lKSB7XG4gICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9zZXRFbnRyeSwgc2V0RW50cnlfZm4pLmNhbGwodGhpcywge1xuICAgICAgbmFtZSxcbiAgICAgIGZpbGVOYW1lLFxuICAgICAgYXBwZW5kOiB0cnVlLFxuICAgICAgcmF3VmFsdWU6IHZhbHVlLFxuICAgICAgYXJnc0xlbmd0aDogYXJndW1lbnRzLmxlbmd0aFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYSBuZXcgdmFsdWUgZm9yIGFuIGV4aXN0aW5nIGtleSBpbnNpZGUgRm9ybURhdGEsXG4gICAqIG9yIGFkZCB0aGUgbmV3IGZpZWxkIGlmIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB3aG9zZSBkYXRhIGlzIGNvbnRhaW5lZCBpbiBgdmFsdWVgLlxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIGZpZWxkJ3MgdmFsdWUuIFRoaXMgY2FuIGJlIFtgQmxvYmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9iKVxuICAgIG9yIFtgRmlsZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlKS4gSWYgbm9uZSBvZiB0aGVzZSBhcmUgc3BlY2lmaWVkIHRoZSB2YWx1ZSBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcuXG4gICAqIEBwYXJhbSBmaWxlTmFtZSBUaGUgZmlsZW5hbWUgcmVwb3J0ZWQgdG8gdGhlIHNlcnZlciwgd2hlbiBhIEJsb2Igb3IgRmlsZSBpcyBwYXNzZWQgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIuIFRoZSBkZWZhdWx0IGZpbGVuYW1lIGZvciBCbG9iIG9iamVjdHMgaXMgXCJibG9iXCIuIFRoZSBkZWZhdWx0IGZpbGVuYW1lIGZvciBGaWxlIG9iamVjdHMgaXMgdGhlIGZpbGUncyBmaWxlbmFtZS5cbiAgICpcbiAgICovXG4gIHNldChuYW1lLCB2YWx1ZSwgZmlsZU5hbWUpIHtcbiAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX3NldEVudHJ5LCBzZXRFbnRyeV9mbikuY2FsbCh0aGlzLCB7XG4gICAgICBuYW1lLFxuICAgICAgZmlsZU5hbWUsXG4gICAgICBhcHBlbmQ6IGZhbHNlLFxuICAgICAgcmF3VmFsdWU6IHZhbHVlLFxuICAgICAgYXJnc0xlbmd0aDogYXJndW1lbnRzLmxlbmd0aFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBrZXkgZnJvbSB3aXRoaW4gYSBgRm9ybURhdGFgIG9iamVjdC5cbiAgICogSWYgeW91IGV4cGVjdCBtdWx0aXBsZSB2YWx1ZXMgYW5kIHdhbnQgYWxsIG9mIHRoZW0sIHVzZSB0aGUgYGdldEFsbCgpYCBtZXRob2QgaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQSBuYW1lIG9mIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byByZXRyaWV2ZS5cbiAgICpcbiAgICogQHJldHVybnMgQSBgRm9ybURhdGFFbnRyeVZhbHVlYCBjb250YWluaW5nIHRoZSB2YWx1ZS4gSWYgdGhlIGtleSBkb2Vzbid0IGV4aXN0LCB0aGUgbWV0aG9kIHJldHVybnMgbnVsbC5cbiAgICovXG4gIGdldChuYW1lKSB7XG4gICAgY29uc3QgZmllbGQgPSBfX3ByaXZhdGVHZXQodGhpcywgX2VudHJpZXMpLmdldChTdHJpbmcobmFtZSkpO1xuICAgIGlmICghZmllbGQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGRbMF07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4ga2V5IGZyb20gd2l0aGluIGEgYEZvcm1EYXRhYCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgbmFtZSBvZiB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcmV0cmlldmUuXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGBGb3JtRGF0YUVudHJ5VmFsdWVgIHdob3NlIGtleSBtYXRjaGVzIHRoZSB2YWx1ZSBwYXNzZWQgaW4gdGhlIGBuYW1lYCBwYXJhbWV0ZXIuIElmIHRoZSBrZXkgZG9lc24ndCBleGlzdCwgdGhlIG1ldGhvZCByZXR1cm5zIGFuIGVtcHR5IGxpc3QuXG4gICAqL1xuICBnZXRBbGwobmFtZSkge1xuICAgIGNvbnN0IGZpZWxkID0gX19wcml2YXRlR2V0KHRoaXMsIF9lbnRyaWVzKS5nZXQoU3RyaW5nKG5hbWUpKTtcbiAgICBpZiAoIWZpZWxkKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBmaWVsZC5zbGljZSgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBzdGF0aW5nIHdoZXRoZXIgYSBgRm9ybURhdGFgIG9iamVjdCBjb250YWlucyBhIGNlcnRhaW4ga2V5LlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG5hbWUgb2YgdGhlIGtleSB5b3Ugd2FudCB0byB0ZXN0IGZvci5cbiAgICpcbiAgICogQHJldHVybiBBIGJvb2xlYW4gdmFsdWUuXG4gICAqL1xuICBoYXMobmFtZSkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2VudHJpZXMpLmhhcyhTdHJpbmcobmFtZSkpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEga2V5IGFuZCBpdHMgdmFsdWUocykgZnJvbSBhIGBGb3JtRGF0YWAgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUga2V5IHlvdSB3YW50IHRvIGRlbGV0ZS5cbiAgICovXG4gIGRlbGV0ZShuYW1lKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9lbnRyaWVzKS5kZWxldGUoU3RyaW5nKG5hbWUpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBbYGl0ZXJhdG9yYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvSXRlcmF0aW9uX3Byb3RvY29scykgYWxsb3dpbmcgdG8gZ28gdGhyb3VnaCBhbGwga2V5cyBjb250YWluZWQgaW4gdGhpcyBgRm9ybURhdGFgIG9iamVjdC5cbiAgICogRWFjaCBrZXkgaXMgYSBgc3RyaW5nYC5cbiAgICovXG4gICprZXlzKCkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIF9fcHJpdmF0ZUdldCh0aGlzLCBfZW50cmllcykua2V5cygpKSB7XG4gICAgICB5aWVsZCBrZXk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIFtgaXRlcmF0b3JgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9JdGVyYXRpb25fcHJvdG9jb2xzKSBhbGxvd2luZyB0byBnbyB0aHJvdWdoIHRoZSBgRm9ybURhdGFgIGtleS92YWx1ZSBwYWlycy5cbiAgICogVGhlIGtleSBvZiBlYWNoIHBhaXIgaXMgYSBzdHJpbmc7IHRoZSB2YWx1ZSBpcyBhIFtgRm9ybURhdGFWYWx1ZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Gb3JtRGF0YUVudHJ5VmFsdWUpLlxuICAgKi9cbiAgKmVudHJpZXMoKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMua2V5cygpKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLmdldEFsbChuYW1lKTtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgIHlpZWxkIFtuYW1lLCB2YWx1ZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIFtgaXRlcmF0b3JgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9JdGVyYXRpb25fcHJvdG9jb2xzKSBhbGxvd2luZyB0byBnbyB0aHJvdWdoIGFsbCB2YWx1ZXMgY29udGFpbmVkIGluIHRoaXMgb2JqZWN0IGBGb3JtRGF0YWAgb2JqZWN0LlxuICAgKiBFYWNoIHZhbHVlIGlzIGEgW2BGb3JtRGF0YVZhbHVlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Zvcm1EYXRhRW50cnlWYWx1ZSkuXG4gICAqL1xuICAqdmFsdWVzKCkge1xuICAgIGZvciAoY29uc3QgWywgdmFsdWVdIG9mIHRoaXMpIHtcbiAgICAgIHlpZWxkIHZhbHVlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQW4gYWxpYXMgZm9yIEZvcm1EYXRhI2VudHJpZXMoKVxuICAgKi9cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyBnaXZlbiBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZWFjaCBmaWVsZCBvZiB0aGUgRm9ybURhdGEgaW5zdGFuY2VcbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgdGhpcykge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWx1ZSwgbmFtZSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJGb3JtRGF0YVwiO1xuICB9XG59O1xuX2VudHJpZXMgPSBuZXcgV2Vha01hcCgpO1xuX3NldEVudHJ5ID0gbmV3IFdlYWtTZXQoKTtcbnNldEVudHJ5X2ZuID0gZnVuY3Rpb24oe1xuICBuYW1lLFxuICByYXdWYWx1ZSxcbiAgYXBwZW5kLFxuICBmaWxlTmFtZSxcbiAgYXJnc0xlbmd0aFxufSkge1xuICBjb25zdCBtZXRob2ROYW1lID0gYXBwZW5kID8gXCJhcHBlbmRcIiA6IFwic2V0XCI7XG4gIGlmIChhcmdzTGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBgRmFpbGVkIHRvIGV4ZWN1dGUgJyR7bWV0aG9kTmFtZX0nIG9uICdGb3JtRGF0YSc6IDIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke2FyZ3NMZW5ndGh9IHByZXNlbnQuYFxuICAgICk7XG4gIH1cbiAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgbGV0IHZhbHVlO1xuICBpZiAoaXNGaWxlKHJhd1ZhbHVlKSkge1xuICAgIHZhbHVlID0gZmlsZU5hbWUgPT09IHZvaWQgMCA/IHJhd1ZhbHVlIDogbmV3IEZpbGUoW3Jhd1ZhbHVlXSwgZmlsZU5hbWUsIHtcbiAgICAgIC8vIG90aGVyd2lzZSwgY3JlYXRlIG5ldyBGaWxlIHdpdGggZ2l2ZW4gZmlsZU5hbWVcbiAgICAgIHR5cGU6IHJhd1ZhbHVlLnR5cGUsXG4gICAgICBsYXN0TW9kaWZpZWQ6IHJhd1ZhbHVlLmxhc3RNb2RpZmllZFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzQmxvYihyYXdWYWx1ZSkpIHtcbiAgICB2YWx1ZSA9IG5ldyBGaWxlKFtyYXdWYWx1ZV0sIGZpbGVOYW1lID09PSB2b2lkIDAgPyBcImJsb2JcIiA6IGZpbGVOYW1lLCB7XG4gICAgICB0eXBlOiByYXdWYWx1ZS50eXBlXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoZmlsZU5hbWUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgYEZhaWxlZCB0byBleGVjdXRlICcke21ldGhvZE5hbWV9JyBvbiAnRm9ybURhdGEnOiBwYXJhbWV0ZXIgMiBpcyBub3Qgb2YgdHlwZSAnQmxvYicuYFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBTdHJpbmcocmF3VmFsdWUpO1xuICB9XG4gIGNvbnN0IHZhbHVlcyA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfZW50cmllcykuZ2V0KG5hbWUpO1xuICBpZiAoIXZhbHVlcykge1xuICAgIHJldHVybiB2b2lkIF9fcHJpdmF0ZUdldCh0aGlzLCBfZW50cmllcykuc2V0KG5hbWUsIFt2YWx1ZV0pO1xuICB9XG4gIGlmICghYXBwZW5kKSB7XG4gICAgcmV0dXJuIHZvaWQgX19wcml2YXRlR2V0KHRoaXMsIF9lbnRyaWVzKS5zZXQobmFtZSwgW3ZhbHVlXSk7XG4gIH1cbiAgdmFsdWVzLnB1c2godmFsdWUpO1xufTtcbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBCbG9iLFxuICBGaWxlLFxuICBGb3JtRGF0YVxufSk7XG4vKiEgQmFzZWQgb24gZmV0Y2gtYmxvYi4gTUlUIExpY2Vuc2UuIEppbW15IFfDpHJ0aW5nIDxodHRwczovL2ppbW15LndhcnRpbmcuc2Uvb3BlbnNvdXJjZT4gJiBEYXZpZCBGcmFuayAqL1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/formdata-node/lib/form-data.cjs\n");

/***/ })

};
;